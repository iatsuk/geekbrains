# Проанализировать скорость и сложность одного любого алгоритма из разработанных в рамках домашнего задания первых
# трех уроков. Примечание. Идеальным решением будет:
# ● выбрать хорошую задачу, которую имеет смысл оценивать,
# ● написать 3 варианта кода (один у вас уже есть),
# ● проанализировать 3 варианта и выбрать оптимальный,
# ● результаты анализа вставить в виде комментариев в файл с кодом,
# ● написать общий вывод: какой из трёх вариантов лучше и почему.

# Задача: Найти сумму n элементов следующего ряда чисел: 1 -0.5 0.25 -0.125...
# Количество элементов (n) вводится с клавиатуры.
n = int(input('Введите глубину ряда: '))


# Решение №1. Динамическое программирование
# Это решение находит искомые элемент за временную сложность O(N) и использует O(N) объема памяти,
# так как все промежуточные элементы необходимо хранить на стеке до окончания рекурсии.
# N     O(N)    t, ms
# 1     1       0.00004
# 10    10      0.00006
# 100   100     0.00012
# 1000  1000    0.00133
import time
import sys
start = time.time()
sys.setrecursionlimit(1500)
k = 0
def series_sum(deep):
    def recursive(elem, deep):
        global k
        k += 1
        return elem if deep == 1 else elem + recursive(elem * -0.5, deep - 1)
    return recursive(1, deep)
summ = series_sum(n)
print('=== Решение 1 ===')
print('Ответ:', summ)
print('Количество операций решения:', k)
print('Время выполнения решения:', time.time() - start, 'мс')


# Решение №2. Полный перебор элементов
# Это решение находит искомый элемент за временную сложность O(N**2) и использует O(1) объема памяти.
# N     O(N)    t, ms
# 1     1       0.00003
# 10    55      0.00004
# 100   5050    0.00131
# 1000  500500  0.09166
start = time.time()
k = 0
summ = 0
for i in range(n):
    k += 1
    elem = 1
    for j in range(i):
        k += 1
        elem /= -2
    summ += elem
print('=== Решение 2 ===')
print('Ответ:', summ)
print('Количество операций решения:', k)
print('Время выполнения решения:', time.time() - start, 'мс')


# Решение №3. Перебор элементов с аккумулятором
# Это решение находит искомый элемент за временную сложность O(N) и использует O(1) объема памяти.
# N     O(N)    t, ms
# 1     1       0.00003
# 10    10      0.00003
# 100   100     0.00005
# 1000  1000    0.00028
start = time.time()
k = 0
summ = 0
elem = 1
for _ in range(n):
    k += 1
    summ += elem
    elem /= -2
print('=== Решение 3 ===')
print('Ответ:', summ)
print('Количество операций решения:', k)
print('Время выполнения решения:', time.time() - start, 'мс')


# Решение №4. Геометрическая прогрессия
# Это решение находит искомый элемент за временную сложность O(1) и использует O(1) объема памяти.
# N     O(N)    t, ms
# 1     1       0.00004
# 10    1       0.00004
# 100   1       0.00004
# 1000  1000    0.00004
start = time.time()
summ = 1 * (1 - (-0.5) ** n) / (1 - (-0.5))
print('=== Решение 4 ===')
print('Ответ:', summ)
print('Количество операций решения:', k)
print('Время выполнения решения:', time.time() - start, 'мс')


# Вывод: Лучшее решение 4, так как имеет наименьшую временную сложность из представленных.
# Решение 1 имеет линейную сложность, но ограничено памятью и величиной стека.
# Решение 2 имеет квадратичную сложность.
# Решение 3, как и решение 1, имеет линейную сложность, но не использует дополнительной памяти.
# Решение 4 выполняется за постоянное время, что является наилучшим решением из представленных.
